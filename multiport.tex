\section{Extending DSA with multiple ports}

Consider a special kind of an alphabet
$\Sigma = \langle \Sigma_1, \Sigma_2, \dots, \Sigma_k \rangle$ such
that $\Sigma_i \cap \Sigma_j = \emptyset$ for all $i, j \in
[1..k]$. We will call $\Sigma_i$ as the alphabet of \emph{port} $i$,
and $\Sigma$ as a \emph{multi-port} alphabet. We
look at DFAs over such multi-port alphabets. Such DFAs model systems
that listen to inputs from different processes and perform actions
based on them. Sometimes the order in which the system receives its
inputs from different ports is not relevant.%
  
For example, at a state
$s$, if the system receives $a$ from port 1 and $b$ from port 2, in any
order, then it has to go to state $t$.  A DFA would model this with
transitions: $s \xra{a} s_a \xra{b} t$ and $s \xra{b} s_b \xra{a}
t$. A DSA would contain two transitions $s \xra{ab, ba} t$ (and some
other transitions, if needed, to take care of $aa$, $bb$). To get a
more succinct notation we will use a $\parallel$ operator. We will
write $s \xra{a \parallel b} t$ to mean that at state $s$, when
both $a$ and $b$ are received, the automaton moves to $t$. When there
are several components, this notation leads to significant
succinctness, for instance $a_1 \parallel a_2 \cdots \parallel a_n$
stands for all the $n!$ permutations of $a_1$ to $a_n$. We will also
allow expressions of the form $a_1 a_2 \parallel b$, which stands for
the set of words $\{a_1 a_2 b, a_1 b a_2, b a_1 a_2\}$ which shuffles
$a_1a_2$ and $b$. We will now formalize this idea by enhancing DSA with
the $\parallel$ operator and then consider the problem of synthesizing
such extended DSA. We begin with some notation.%

\paragraph*{Notation.} For a word $w \in \Sigma^*$, we write
$\proj{i}(w)$ for the projection of $w$ onto the set $\Sigma_i$. For
instance, if $\Sigma_1 = \{a_1, a_2\}, \Sigma_2 = \{b_1, b_2\}$ and
$w = a_1 b_1 a_2 a_1 b_2 b_2$, we have $\proj{1}(w) = a_1 a_2 a_1$ and
$\proj{2}(w) = b_1 b_2 b_2$.  We write $\partial w$ for the $k$-tuple
$(\proj{1}(w), \proj{2}(w), \dots, \proj{k}(w))$ of projections of $w$
onto each port $\Sigma_i$, and will call $\partial w$ the
\emph{decomposition} of $w$. Notice that if
$\partial w_1 = \partial w_2$ for two words $w_1, w_2$, then $w_1$ and
$w_2$ have the same order of events within each port, but could have a
different ordering between letters from different ports.%


\paragraph*{Challenges in extending to multiport.} In a DSA, each configuration maintained the current state $q$ and the word $w$ seen after reaching $q$. This was sufficient to determine whether an outgoing transition matches. In the concurrent case, we would like our transition labels to be of the form $u_1 \parallel u_2 \parallel \cdots \parallel u_k$, with the intention that each $u_i$ is a suffix of the projection $\proj{i}(w)$. This is a natural extension so far. However, suppose a transition matches. In the DSA, we simply consume the word and go to a new configuration $(q', \epsilon)$. What is the counterpart in the concurrent case? One option is to consume the word, again, in all the ports. This is unsatisfactory: suppose the rule talks only about ports $1$ and $2$, while in state $q$ we have been receiving signals on port $3$ as well, on firing the rule, we may reach a state that depends on the signals on port $3$ received previously. Therefore, we do not want to consume the sequences seen in ports outside the fired rule. For similar reasons, sometimes we do not want to consume the letters even in the ports present in the rule. Here is an example (\textcolor{red}{TODO}). 

To cater to these different situations, we equip the automaton with multiple tape heads. Each tape head points to a position in the word seen so far. The rules can then specify the tape head since when the pattern is required to be true. Here is an example (\textcolor{red}{TODO}).

\paragraph*{Formal definition.} In multiport DSAs, the transition are labeled with a richer syntax. They make use of a parallel operator $\parallel$ and also specify a tape head.

\begin{definition} Let
  $\Sigma = \langle \Sigma_1, \Sigma_2, \dots, \Sigma_k \rangle$ be a
  multi-port alphabet. A \emph{multi-port (deterministic)
    suffix-reading automaton} (written mDSA in short) $\Aa$ is a
  tuple $(Q, \Sigma, L, q^{init}, \delta, \pi, F)$ where $Q$, $q^{init}$ and
  $F$ are a finite set of states, the initial state and a set of
  accept states, respectively; $L = \{\lt_1, \lt_2, \dots, \lt_p\}$ denotes a set of tape heads. The transition relation
  $\delta \incl Q \times (L \times\Sigma_1^* \times \Sigma_2^* \times \cdots
  \times \Sigma_k^*) \times Q$: each transition is of the form
  $(q, (\lt_j: u_1 \parallel u_2 \parallel \cdots \parallel u_k), q')$ where
  $u_i \in \Sigma_i^*$ (not all of them can be $\epsilon$) and $\lt_j$ is a tape head of $L$. We assume there are only finitely many transitions. The \emph{priority function} $\pi$ gives a total order on the set of transitions. 
 \end{definition}%

 Here is an example to illustrate the syntax of an mDSA. \textcolor{red}{(TODO)}.

 For the semantics, we assume that there is a tape on which the automaton writes all its inputs. Initially, the tape is $\epsilon$. Each time an input letter $a \in \Sigma$ is received, the automaton appends it to the right of the tape. The $p$ tape heads $\lt_1, \lt_2, \dots, \lt_p$ point to various positions in the tape. A \emph{tape configuration} is therefore given as $(T, i_1, i_2, \dots, i_p)$ where $T$ is the current word in the tape, and $i_1, \dots, i_p \in \Nat$ are the positions pointed to by the heads $\lt_1, \dots, \lt_p$ respectively. A \emph{configuration} of an mDSA is then given by a state $q$ and a tape configuration: $(q, T, i_1, \dots, i_p)$. 

Given a tape content $T$ and position $i \in \Nat$, we write $T(i)$ for the letter in the $i^{th}$ position of the tape. For two indices $i, j$ we write $T[i, j]$ to denote the substring $T(i) T(i+1) \cdots T(j)$ of the tape $T$. We will write $|T|$ to denote the length of the tape.

A transition $(q, \lt_j: u_1 \parallel u_2 \parallel \cdots \parallel u_k, q')$ matches  $(q, T, i_1, i_2 \dots, i_p)$ if
\begin{itemize}
\item $u_i$ is a suffix of $\proj{i}(T)$ for all ports $i$,
\item at least one $u_i$ occurs entirely after the tape head $\lt$: that is, $u_i$ is a subword of the word $T(i_{j}+1, |T|]$.
\end{itemize} 

Here are some examples to illustrate this definition. \textcolor{red}{(TODO)}

The formal semantics of an mDSA is given by a transition system over the configurations. The initial configuration is $(q^{init}, \vdash, 0, 0, \dots,0)$ where $\vdash$ represents a special symbol denoting the beginning of the tape (in other words, the position $0$ in the tape). All the tape heads are initially at position $0$. 
From a configuration $(q, T, i_1, \dots, i_p)$, on receiving a letter $a$, there are two possible transitions: 
\begin{itemize}
  \item $(q, T, i_1, \dots, i_p) \xra{a} (q, Ta, i_1, \dots, i_p)$, if no transition out of $q$ matches the resulting configuration $(q, Ta, i_1, \dots, i_p)$,
  \item $(q, T, i_1, \dots, i_p) \xra[\rho]{a} (q', T a, i'_1, i'_2, \dots, i'_p)$ if $\rho: (q, \lt_j: u_1 \parallel u_2 \parallel \cdots \parallel u_k)$ is the transition out of $q$ with the highest priority $\pi$, that matches $(q, Ta, i_1, \dots, i_p)$; moreover, $i'_j = |T a|$ (tape head $\lt_j$ moves to the end of the tape), and $i'_{m} = i_m$ for all other $m$ (other tape heads remain in their position).
\end{itemize}

Here are some examples to illustrate the full mechanics of an mDSA \textcolor{red}{(TODO)}.

A configuration $(q, T, i_1, \dots, i_k)$ is said to be accepting if $q \in F$ and at least one of the tape heads is in the final position $|T|$. From a technical viewpoint, this definition of accepting configurations allows us to extend DSAs. Moreover, if we think of accepting states to denote some errors, this definition ensures that as soon as a rule leading to an error is triggered, it will be accepted. \textcolor{red}{Cleaner to change to acceptance on transitions?}

\subsection{DSA is a special mDSA.}














  
