\section{Multiport DSAs with outputs}

In the last section, we have seen multi-port DSAs which process inputs across several ports and match transitions. In many situations, requirements also talk about outputting values to certain ports when transitions match. Here is an example of some requirements of a \emph{Car Alarm module}, adapted from~\cite{DBLP:conf/enase/VenkateshSZA15a}. 
\begin{enumerate}
\item If the most recent values on Ports \emph{I} (Ignition) and \emph{A} (Alarm) are \emph{F}(Off), and the last two values on the Port \emph{P} are $P;P$ (Press), then
the value \emph{N}(On) is output on the port \emph{A}.

\item If the last three values on Port \emph{P} are $R;R;R$ (Release), and the last value for \emph{A} is \emph{N}, then output the value \emph{F} (False) on \emph{F}
and output \emph{F} on \emph{A}.

\item If last value on \emph{I} is \emph{N}, then \emph{F} is output on \emph{F} and \emph{F} is output on \emph{A}.
\end{enumerate}
The first requirement checks for $I:Off \parallel A:Off \parallel P:Press;Press$ and immediately writes $On$ in port $A$. The check-and-update is a fully atomic operation. One way to model this requirement as an mDSA would be to absorb port $A$ as part of the state: that is the state of the mDSA is defined using values of such variables. However, this would lead to an exponential blowup in the number of states, if there are multiple such ports that are both read and written on transitions. To succinctly capture requirements with outputs, we allow both reads and writes on all ports and define \emph{mDSAs with outputs}. 

\subsection{mDSA-with-outputs: formal syntax and semantics}

The syntax of mDSA with outputs is almost the same as that of DSAs. The only difference is in the syntax of transitions.  As before, there is a multiport alphabet $\Sigma = \langle \Sigma_1, \dots, \Sigma_k \rangle$. An mDSA-with-outputs $\Bb$ is a tuple $(Q, \Sigma, q^{init}, \delta, F)$ where $Q$ is a finite set of states, $q^{init}$ is the initial state and $F$ is a set of accept states, $\delta$ is a finite set of transitions.

\paragraph*{Transitions.} A transition now looks like:
\begin{align*}
q \xra[~~O_1: b_1 \parallel O_2: b_2 \parallel \cdots \parallel O_m: b_m~~]{I_1: u_1 \parallel I_2: u_2 \parallel \cdots \parallel I_k: u_k} q'
\end{align*}
where $q, q'$ are states; each $u_j$ is a word in the port alphabet of $I_j$; and each $b_j$ is a letter in the port alphabet of $O_j$. We remark that $\{I_1, \dots, I_k\} \cap \{O_1, \dots, O_m\}$ may be non-empty. In other words, some of the ports may appear both as input and output in a transition.  

\paragraph*{Semantics.} Configurations of $\Bb$ are the same as before, given by $(q, w, \theta)$ with $q$ a state, $w$ the word seen so far and $\theta$ a position of the tape head. The semantics is a transition system $\Ss^\Bb = (S, s_0, \xra{}, F)$ where $S$ is the set of configurations, $s_0$ the initial configuration $(q^{init}, \epsilon, 0)$, $S_F$ the accepting configurations which are $(q, w, \theta)$ with $q \in F$ and $\theta = |w|$. There are three kinds of transitions. Let $\rho$ be a transition $(q, (I_1: u_1 \parallel \cdots I_\ell:u_\ell), (O_1: b_1 \parallel \cdots \parallel O_m: b_m), q')$.
\begin{itemize}
\item $(q, w, \theta) \xra[\rho]{\epsilon} (q', wb_1 b_2 \dots b_m, |w|)$ if the input condition $I_1:u_1 \parallel \cdots \parallel I_\ell:u_\ell$ matches the tape configuration $(w, \theta)$; in that case move the tape head to end of $w$ and write all the outputs to the right of $w$ (order of writing does not matter).
\item if no outgoing transition matches $(w, \theta)$ then there is no $\epsilon$ transition out of $(q, w, \theta)$ and the mDSA-with-outputs listens to further input letters. We have:
\begin{itemize}
\item $(q, w, \theta) \xra[\rho]{a} (q', wab_1 b_2 \dots b_m, |wa|)$ if $I_1:u_1 \parallel \cdots \parallel I_\ell:u_\ell$ matches $(wa, \theta)$; then, move the tape head to the right of $wa$ and write the outputs after that,
\item $(q, w, \theta) \xra{a} (q', wa, \theta)$ if no transition out of $q$ matches $(w, \theta)$.
\end{itemize}
\end{itemize} 

\subsection{Complexity of emptiness checking}

We now look at the problem of checking emptiness of an mDSA-with-outputs: given an mDSA-with-outputs $\Bb$, does there exist a word that reaches an accepting configuration? Without outputs, this problem is simply a graph reachability problem, like in a DFA or a DSA. The presence of outputs makes this problem harder. Here is an example that illuminates this difficulty.

\subsubsection*{$N$-bit counter.} We wish to implement addition of an $N$-bit counter using an mDSA-with-outputs that has $2$ state, $N+1$ ports and $N$ transitions. Suppose $b_{N-1} b_{N-2} \dots b_1 b_0$ are the $N$ bits, with $b_{N-1}$ the most significant bit and $b_0$ the least significant bit. Addition can be implemented using $N$ rules: for $j \in \{0, \dots, N-1\}$
\begin{itemize}
\item if $b_j = 0$ and $b_{j-1} = b_{j-2} = \cdots = b_0 = 1$, then change $b_j:= 1$ and $b_{j-1} = b_{j-2} = \cdots = b_0 := 0$
\end{itemize}
Starting from $0$ for all bits, there will be exactly one rule that will be applicable each time. Applying the relevant rule each time will lead to $b_{N-1} = b_{N-2} = \cdots = b_0 = 1$.

To model this counter using an mDSA-with-outputs, we can use $N$ ports $b_{N-1}, b_{N-2}, \dots, b_0$ each having two values $\{0, 1\}$ and one additional port $I = \{ \checkmark, \times \}$ denoting an alphabet with two actions. We want to accept the single word $(\checkmark)^{2^N}$. The mDSA-with-outputs $\Bb^N$ has states $\{q_0, f\}$ and has the following transition for $j\in \{0, \dots, N-1\}$:
\begin{align*}
q_0 \quad \xra[~~b_j:1 ~\parallel~ b_{j-1}:0 ~\parallel~ \cdots ~\parallel~ b_0: 0~~]{\checkmark ~\parallel~ b_j:0 ~\parallel~ b_{j-1}:1 ~\parallel~ \cdots ~\parallel~ b_0: 1} \quad q_0
\end{align*}
To mark the end of the computation, we add an extra transition from $q_0$ that checks if $b_{N-1}:1 \parallel b_{N-1}:1 \parallel \cdots \parallel b_0:1$ and moves to $f$. State $q_0$ is initial and $f$ is final. The only word accepted by this automaton is $(\checkmark)^{2^N}$. Therefore, the witness for non-emptiness is a word with length exponential in the size of the input automaton. Notice that we have crucially used the ability to have ports that can be used both as inputs and outputs. Without the outputs which get instantaneously updated, we will not be able to count the number of $\checkmark$s. 

We now pin down the complexity of the emptiness problem in mDSA-with-outputs. 

\endinput
In order to represent Expressive Decision Tables (EDTs) succinctly, we require an additional feature in the automaton -- the presence of output ports and more importantly input/output (IO) ports. When a transition is matched, we also require a certain output to be produced in an output port. Sometimes, these output ports can also be treated as inputs and checked for suffixes in the transition labels. Such ports will be called IO ports. Addition of these special ports enables a clean translation of EDTs to mDSAs. At the same time, as we will see, they make the emptiness problem significantly more complex. 

\subsection{Formal syntax} 

Below, we detail each element in the syntax of mDSA-with-outputs.

\paragraph*{The multiport alphabet.} The multiport alphabet is now partitioned into three kinds: input ports, IO ports, and output ports. Let $\sigmain = (\Sigma_1^{i}, \Sigma_2^{i}, \dots, \Sigma_{k_1}^{i})$ be a set of input ports, $\sigmaio =(\Sigma_1^{io}, \Sigma_2^{io}, \dots, \Sigma_{k_2}^{io})$ be a set of IO ports and $\sigmaout = (\Sigma_1^{o}, \Sigma_2^{o}, \dots, \Sigma_{k_3}^{o})$ be a set of output ports. Each port is a finite alphabet. Further, we assume that no two alphabets coincide: therefore, each letter uniquely identifies the port that it is present in. 

\paragraph*{Tape heads.} The automaton is equipped with a set $L = \{ \lt_1, \lt_2, \dots, \lt_p\}$ of tape heads. 

\paragraph*{States.} States of an mDSA are now partitioned into two kinds: \emph{read states} which are the usual kind of states that receive inputs and match transitions, and \emph{write states} which simply write new values to (some of) the IO and output ports. In pictures, we represent read states using circles and write states using squares. We denote by $Q_r$ and $Q_w$ the set of read states and write states respectively. There is an initial state $q^{init}$ which could be either a read or a write state. 

\paragraph*{Transitions.} Transitions out of read states $q$ look the same as before: $(q, (\lt: u_1 \parallel u_2 \parallel \cdots \parallel u_k), q')$ where $q'$ could be any state (read/write) and each $u_j$ is a word in some $(\Sigma^i_\ell)^*$ (input port) or $(\Sigma^{io}_\ell)^*$ (IO port).  We assume that not all $u_j$ are $\epsilon$. As before, $\lt$ denotes a tape head. 

From a write state $q$, there is a unique outgoing transition of the form: $(q, b_1 \parallel b_2 \cdots \parallel b_k, q')$ where $q'$ is a read state and each $b_i$ is a letter in some  $\Sigma^{io}_\ell$ (IO port) or $\Sigma^o_j$ (output port). So transitions out of an output state write new values to some of the IO and output ports.

Notice that transitions from read states can lead to either read or write states, whereas transitions out of write states lead to read states; and read transitions can look for a combination of suffixes ($u_j$ are words) whereas write transitions write a single letter ($b_j$ are letters).

\paragraph*{Acceptance condition.} The acceptance condition is given by a set of transitions out of read states.

\paragraph*{Example.} We present an example in... \textcolor{red}{(TODO)}. We make use of shortcuts in definitions, explain that.

\subsection{Semantics}

A configuration is given by $(q, T, i_1, \dots, i_p)$ where $i_1, \dots, i_p$ denote the positions of the tape heads. 

From a read state, we have transition $(q, T, i_1, \dots, i_p) \xra{a} (q, Ta, i_1, \dots, i_p)$ and $(q, T, i_1, \dots, i_p) \xra[\rho]{a} (q', Ta, i'_1 \dots i'_p)$ as before. 

If $q$ is a write state, then there is a unique outgoing transition $(q, b_1 \parallel b_2 \cdots \parallel b_k, q')$. The idea is to add $b_1, \dots, b_k$ into the input tape, in some order (actual order does not matter). So we have a transition $(q, Tb_1 b_2 \dots b_k, i_1, \dots, i_p)$.


These writes may induce a rule $q'$ to already match, even before seeing another input. Therefore, we allow $\epsilon$ transitions from read states: $(q, T, i_1, i_2, \dots, i_p) \xra[\rho]{\epsilon} (q', T, i'_1, \dots, i'_p)$ which simply change state and move the tape heads (with the same semantics). 